<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="jiuchengBlog 博客">
    <meta name="description" content="hello, here is JiuCheng&#39; s blog">
    <meta name="author" content="馨er">
    
    <title>
        
            大话数据结构笔记 |
        
        馨er的学习之路
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jiucheng120.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/logo.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.png","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                馨er的学习之路
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class href="/">
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/archives">
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/categories">
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/tags">
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/about">
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">大话数据结构笔记</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">馨er</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-04-19 10:38:25</span>
        <span class="mobile">2021-04-19 10:38</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <blockquote>
<p>数据结构的详细笔记，对应课本</p>
</blockquote>
<span id="more"></span>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><h2 id="1-1-基本概念和术语"><a href="#1-1-基本概念和术语" class="headerlink" title="1.1 基本概念和术语"></a>1.1 基本概念和术语</h2><p><strong>数据：</strong>是描述客观事物的符号，是计算机中操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型（信息的载体；对客观事物符号化的表示；能够被计算机识别，存储和加工）</p>
<p><strong>数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录、结点或顶点。 例如，人。</p>
<p><strong>数据项：</strong>一个数据元素可以由若干个数据项组成。例如人有眼、耳、鼻、嘴、手、脚这些数据项，也可以有姓名、年龄、性别等数据项，要视所做的系统来决定。 <strong>数据项是数据不可分割的最小单位</strong></p>
<blockquote>
<p>数据 &gt; 数据元素 &gt; 数据项</p>
</blockquote>
<p><strong>数据对象：</strong>是性质相同的数据元素的集合，是数据的子集。数据元素是数据的个体，数据对象是数据的子集</p>
<p><strong>数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。数据元素相互之间的关系称为结构。数据结构是带结构的数据元素的集合</p>
<h2 id="1-2-数据结构的两个层次"><a href="#1-2-数据结构的两个层次" class="headerlink" title="1.2 数据结构的两个层次"></a>1.2 数据结构的两个层次</h2><h3 id="1-2-1-逻辑结构"><a href="#1-2-1-逻辑结构" class="headerlink" title="1.2.1 逻辑结构"></a>1.2.1 逻辑结构</h3><p>逻辑结构是指数据对象中数据元素之间的相互关系。与数据的存储无关，独立于计算机，具体分为以下四种</p>
<p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系</p>
<p>线性结构：线性结构中的数据元素之间是一对一的关系。例如：线性表、栈、队列、串</p>
<p>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</p>
<p>图形结构：图形结构的数据元素是多对多的关系</p>
<p>用示意图表示逻辑结构时应注意：</p>
<ul>
<li>将每一个数据元素看做一个结点，用圆圈表示</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</li>
</ul>
<h3 id="1-2-2-物理结构"><a href="#1-2-2-物理结构" class="headerlink" title="1.2.2 物理结构"></a>1.2.2 物理结构</h3><p>物理结构是指数据的逻辑结构在计算机中的存储形式，有时也称存储结构，是数据结构在计算机中的表示</p>
<p>顺序存储结构：是指把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。C语言用数组实现</p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。C语言用指针实现</p>
<p>索引存储结构：在存储结点信息的同时，还建立附加的索引表</p>
<p>散列存储结构：根据结点的关键字直接计算出该结点的存储地址。散列表</p>
<blockquote>
<p>两者关系：<br>物理结构是逻辑关系的映像和元素本身的映像；逻辑结构是数据结构的抽象，物理结构是数据结构的实现</p>
</blockquote>
<h2 id="1-3-抽象数据类型"><a href="#1-3-抽象数据类型" class="headerlink" title="1.3 抽象数据类型"></a>1.3 抽象数据类型</h2><h3 id="1-3-1-数据类型"><a href="#1-3-1-数据类型" class="headerlink" title="1.3.1 数据类型"></a>1.3.1 数据类型</h3><p>是指性质相同的值的集合及定义在此集合上的一些操作的总称。它是按照值的不同进行划分的</p>
<ul>
<li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li>
<li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据构成的</li>
</ul>
<h3 id="1-3-2-抽象数据类型"><a href="#1-3-2-抽象数据类型" class="headerlink" title="1.3.2 抽象数据类型"></a>1.3.2 抽象数据类型</h3><p>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部表示和实现无关，而链式存储关系并不能反映其逻辑关系，因此需要一个指针存放数据元素的地址，通过地址找到相关联数据元素的位置</p>
<p>抽象是指抽取出事物具有的普遍性的本质，其意义在于数据类型的数学抽象特性。抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来</p>
<h2 id="1-4-算法"><a href="#1-4-算法" class="headerlink" title="1.4 算法"></a>1.4 算法</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p>
<h3 id="1-4-1-算法的描述"><a href="#1-4-1-算法的描述" class="headerlink" title="1.4.1 算法的描述"></a>1.4.1 算法的描述</h3><ul>
<li>自然语言：英语，中文</li>
<li>流程图：传统流程图、NS流程图</li>
<li>伪代码：类C语言</li>
<li>程序代码：…</li>
</ul>
<h3 id="1-4-2-算法的特性"><a href="#1-4-2-算法的特性" class="headerlink" title="1.4.2 算法的特性"></a>1.4.2 算法的特性</h3><ul>
<li>算法具有零个或多个输入，至少一个或多个输出</li>
<li>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</li>
<li>确定性：算法的每一步骤都具有确定的含义，不会出现二义性</li>
<li>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</li>
</ul>
<h3 id="1-4-3-算法设计的要求"><a href="#1-4-3-算法设计的要求" class="headerlink" title="1.4.3 算法设计的要求"></a>1.4.3 算法设计的要求</h3><ul>
<li>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</li>
<li>可读性：算法设计的另一目的是为了便于阅读、理解和交流</li>
<li>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果</li>
<li>时间效率高，存储量低</li>
</ul>
<h3 id="1-4-4-算法效率的度量方法"><a href="#1-4-4-算法效率的度量方法" class="headerlink" title="1.4.4 算法效率的度量方法"></a>1.4.4 算法效率的度量方法</h3><p>（1）事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。缺陷多，一般不使用</p>
<p>（2）事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。一个程序的运行时间，依赖于算法的好坏和问题的输入规模</p>
<h3 id="1-4-5-函数的渐近增长"><a href="#1-4-5-函数的渐近增长" class="headerlink" title="1.4.5 函数的渐近增长"></a>1.4.5 函数的渐近增长</h3><p>关注主项的阶数</p>
<h3 id="1-4-6-算法时间复杂度"><a href="#1-4-6-算法时间复杂度" class="headerlink" title="1.4.6 算法时间复杂度"></a>1.4.6 算法时间复杂度</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p><strong>算法时间复杂度：</strong> 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数</p>
<h4 id="2-推导大O阶步骤"><a href="#2-推导大O阶步骤" class="headerlink" title="2  推导大O阶步骤"></a>2  推导大O阶步骤</h4><ul>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是1，则去除这个项相乘的常数，结果就是大O阶</li>
</ul>
<h4 id="3-具体阶数"><a href="#3-具体阶数" class="headerlink" title="3 具体阶数"></a>3 具体阶数</h4><ul>
<li><p>常数阶<br>顺序结构，分支结构</p>
</li>
<li><p>线性阶<br>循环结构</p>
</li>
<li><p>对数阶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= n)&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O($log_2n$))</p>
</li>
<li><p>平方阶<br>时间复杂度为O($n^2$)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line">    n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>nlogn阶<br>2n+3nlog2(n)+19对应O(nlogn)</p>
</li>
<li><p>立方阶</p>
</li>
<li><p>指数阶</p>
<p>  $2^n$对应O($2^n$)</p>
</li>
</ul>
<p>常用的时间复杂度所耗费的时间从小到大依次是：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$) &lt; O(n!) &lt; O($n^n$)</p>
<p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。除非特别指定，我们提到的运行时间都是最坏时间复杂度。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</p>
<h3 id="1-4-7-算法空间复杂度"><a href="#1-4-7-算法空间复杂度" class="headerlink" title="1.4.7 算法空间复杂度"></a>1.4.7 算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，包括指令空间、数据空间、动态申请的内存空间等，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数</p>
<p>算法要占据的时间包括：算法本身要占据的空间，输入/输出，指令，常数，变量等；算法要使用的<strong>辅助空间</strong></p>
<p>（1）S(n) = n + $n^2$ ，则空间复杂度为O($n^2$)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> **b = <span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）S(n) = O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    t = a[i];</span><br><span class="line">    a[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">    a[n - i - <span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）S(n) = O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-线性表的定义"><a href="#2-1-线性表的定义" class="headerlink" title="2.1 线性表的定义"></a>2.1 线性表的定义</h2><p>线性表：零个或多个元素的有限序列</p>
<h2 id="2-2-线性表的抽象数据类型"><a href="#2-2-线性表的抽象数据类型" class="headerlink" title="2.2 线性表的抽象数据类型"></a>2.2 线性表的抽象数据类型</h2><p>线性表的数据对象集合为{$a_1$,$a_2$,……,$a_n$}，每个元素的类型均为DataType。其中，除第一个元素$a_1$外，每一个元素有且只有一个直接前趋元素，除了最后一个元素$a_n$外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InitList(*L);   <span class="comment">//初始化操作，建立一个空的线性表L</span></span><br><span class="line">ListEmpty(L);   <span class="comment">//若线性表为空，返回true，否则返回false</span></span><br><span class="line">ClearList(*L);   <span class="comment">//将线性表清空</span></span><br><span class="line">GetElem(L,i,*e);  <span class="comment">//将线性表L中的第i个位置元素值返回给e</span></span><br><span class="line">LocateElem(L,e);  <span class="comment">//若线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败</span></span><br><span class="line">ListInsert(*L,i,e);  <span class="comment">//在线性表L中的第i个位置插入新元素e</span></span><br><span class="line">ListDelete(*L,i,*e);  <span class="comment">//删除线性表L中第i个位置元素，并用e返回其值</span></span><br><span class="line">ListLength(L);    <span class="comment">//返回线性表L的元素个数</span></span><br></pre></td></tr></table></figure>
<p>求A = A并B，假设La表示集合A，Lb表示集合B，则实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List* La,List Lb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> La_len,Lb_len,i;</span><br><span class="line">    ElemType e;<span class="comment">//声明与La和Lb相同的数据元素e</span></span><br><span class="line">    La_len = ListLength(La);<span class="comment">//求线性表的长度</span></span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Lb_len; i++ )&#123;</span><br><span class="line">        GetElem(Lb, i, e);<span class="comment">//取Lb中第i个数据元素赋给e</span></span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(La, e, equal))<span class="comment">//La中不存在和e相同数据元素</span></span><br><span class="line">            ListInsert(La, ++La_len, e);<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于复杂的个性化操作，就是把基本操作组合起来实现</p>
<h2 id="2-3-线性表的顺序存储结构"><a href="#2-3-线性表的顺序存储结构" class="headerlink" title="2.3 线性表的顺序存储结构"></a>2.3 线性表的顺序存储结构</h2><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。可以用一维数组来实现，一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间是固定的，一旦空间占满，就无法再新增数据，否则会导致数据溢出；而在动态分配时，存储数组的空间在程序执行过程中会动态调整大小，当空间占满时，可以另行开辟更大的存储空间来储存数据</p>
<p>顺序表最主要的特点是可以进行<strong>随机访问</strong>，即可以通过表头元素的地址和元素的编号（下标），在O(1)的时间复杂度内找到指定的元素。顺序表的不足之处是插入和删除操作需要移动大量的元素，从而保持逻辑上和物理上的连续性</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert(loc, value)</td>
<td align="center">将value插入到顺序表中下标为loc的位置</td>
</tr>
<tr>
<td align="center">expand()</td>
<td align="center">扩大顺序表的容量</td>
</tr>
<tr>
<td align="center">search(value)</td>
<td align="center">寻找顺序表中值为value的元素</td>
</tr>
<tr>
<td align="center">remove(index)</td>
<td align="center">将顺序表下标为index的元素</td>
</tr>
<tr>
<td align="center">print()</td>
<td align="center">输出顺序表中所有元素</td>
</tr>
</tbody></table>
<ol>
<li><p>插入操作实现方法：</p>
<ul>
<li>判断插入位置是否合法</li>
<li>判断顺序表是否已满</li>
<li>将目标位置及以后的元素后移一位</li>
<li>将待插入的元素后移一位</li>
</ul>
</li>
<li><p>扩容操作实现方法：</p>
<p>我们需要把原数组空间里的元素一一复制到新的空间内，因此扩容的时间复杂度为O(n)</p>
<ul>
<li>将原来的元素存储到临时存储空间</li>
<li>扩大原来的存储空间</li>
<li>将临时存储空间里的数据元素复制到新的存储空间里</li>
<li>释放临时的存储空间</li>
</ul>
</li>
<li><p>查找操作实现方法：</p>
<ul>
<li>从下标为0的元素开始依次枚举顺序表中的所有元素</li>
<li>发现和目标值相等的元素则返回它的下标</li>
<li>枚举结束没有找到目标元素则返回 -1</li>
</ul>
</li>
<li><p>删除操作实现方法：</p>
<ul>
<li>判断传入参数是否合法，即下标是否在顺序表的范围内</li>
<li>将目标下标之后所有的元素前移一位</li>
<li>更新顺序表的长度</li>
</ul>
</li>
<li><p>遍历操作实现方法：</p>
<ul>
<li>从下标为0的元素开始遍历顺序表</li>
<li>输出所有元素的值</li>
</ul>
</li>
</ol>
<p>顺序存储结构的三个属性：</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量：MAXSIZE</li>
<li>线性表的当前长度：length</li>
<li>$logn$</li>
</ul>
<p>注意区分数组长度和线性表长度，线性表长度应该小于等于数组的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType* elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">DestroyList_Sq</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    L.elem = <span class="literal">NULL</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ClearList_Sq</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L.length &amp;&amp; L.elem[i] != e)</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; L.length)</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    ElemType* p, * q, * newbase;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.listsize) &#123;</span><br><span class="line">        newbase = (ElemType*)<span class="built_in">realloc</span>(L.elem, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += LISTINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">        *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    ElemType* p, * q;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i&gt;L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = &amp;(L.elem[i - <span class="number">1</span>]); <span class="comment">// p为被删除元素的位置</span></span><br><span class="line">    e = *p; <span class="comment">// 被删除元素的位置赋给e</span></span><br><span class="line">    q = L.elem + L.length + <span class="number">1</span>; <span class="comment">// 表尾元素的位置</span></span><br><span class="line">    <span class="keyword">for</span> (++p; p &lt;= q; ++p)</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispList_Sq</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, L.elem[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序表的基本运算如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （1）初始化顺序表L\n&quot;</span>);</span><br><span class="line">    InitList_Sq(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （2）依次插入a, b, c, d, e元素\n&quot;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （3）输出顺序表L：&quot;</span>);</span><br><span class="line">    DispList_Sq(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （4）顺序表L长度：%d\n&quot;</span>, ListLength_Sq(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （5）顺序表L为%s\n&quot;</span>, ListEmpty_Sq(L) ? <span class="string">&quot;空&quot;</span> : <span class="string">&quot;非空&quot;</span>);</span><br><span class="line">    GetElem_Sq(L, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （6）顺序表L的第3个元素：%c\n&quot;</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （7）元素a的位置：%d\n&quot;</span>, LocateElem_Sq(L, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （8）在第4个元素位置上插入f元素\n&quot;</span>);</span><br><span class="line">    ListInsert_Sq(L, <span class="number">4</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （9）输出顺序表L：&quot;</span>);</span><br><span class="line">    DispList_Sq(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （10）删除L的第3个元素\n&quot;</span>);</span><br><span class="line">    ListDelete_Sq(L, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （11）输出顺序表L：&quot;</span>);</span><br><span class="line">    DispList_Sq(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  （12）释放顺序表L\n&quot;</span>);</span><br><span class="line">    DestroyList_Sq(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++的动态内存分配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line">p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> p1, p2;</span><br></pre></td></tr></table></figure>


<h2 id="2-4-线性表的链式存储结构"><a href="#2-4-线性表的链式存储结构" class="headerlink" title="2.4 线性表的链式存储结构"></a>2.4 线性表的链式存储结构</h2><p>为了表示每个数据元素a1与其直接后继数据元素a(i+1)之间的逻辑关系，对数据元素a1来说，除了存储其本身的信息以外，还需存储一个指示其直接后继的 信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点。</p>
<p>n个结点（ai的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因此此链表的每个结点只包含一个指针域，所以叫做单链表。链表第一个结点的存储位置叫做头指针。有时，为了方便操作，会在单链表的第一个结点前附设一个结点，称为头结点</p>
<table>
<thead>
<tr>
<th>头指针</th>
<th>头结点</th>
</tr>
</thead>
<tbody><tr>
<td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td>
<td>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</td>
</tr>
<tr>
<td>头指针具有标识的作用，所以常用头指针冠以链表的名字</td>
<td>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</td>
</tr>
<tr>
<td>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</td>
<td>头结点不一定是链表必须要素</td>
</tr>
</tbody></table>
<p>重复利用指针建立链表</p>
<ol>
<li>如果链表为空链表，那么就可以直接将head指针赋给NILL，而无须进行其他操作；</li>
<li>如果链表不为空，那么首先使用一个malloc函数新建一个结点，使head、p1和p2都指向它。它就是这个链表的头结点；</li>
<li>对结点内的数据进行赋值，从而完成该结点的初始化工作；</li>
<li>开辟另外一个结点，并使p1指向这个新开辟的结点；</li>
<li>如果链表还未满足结束条件，那么继续将这个新的结点链入链表，也就是将p1的值赋给p2-&gt;next（注意这个时候p2仍指向第一个结点），所以在执行了语句p2-&gt;next=p1之后，新结点就被成功链入链表了；</li>
<li>让指针p2向后移动一个位置，即执行语句p2=p1，也就是使p2指向最新建立的结点；</li>
<li>再次开辟一个新结点并初始化它；</li>
<li>再次将指针p1指向这个新结点。如果链表仍然未满足结束条件，那么继续将这个新的结点链入链表，也就是将p1的值赋给p2-&gt;next=p1之后，新结点同样被成功链入链表；</li>
<li>再像前面一样将指针p2向后移动一个位置，即执行语句p2=p1，也就是使p2再次指向最新建立的结点</li>
<li>如果仍有新的数据被接收，那么就再次为该数据开辟一个结点，并让指针p1指向这个新结点，并按照前面的操作方式继续为链表添加新数据；</li>
<li>如果链表满足结束条件或者达到事前预定的长度，那么循环操作就将被中止。新的结点也不再被链入链表中。这个时候即将NULL赋给p2-&gt;next，表示该结点为整个链表的尾结点。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert(node, index)</td>
<td align="center">将node插入到链表中下标为index的位置</td>
</tr>
<tr>
<td align="center">output()</td>
<td align="center">输出整个链表</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>链表的遍历</p>
<ol>
<li>以链表的表头结点作为输入；</li>
<li>设一个指针变量p，先指向第一个结点，并输出该结点中的数据；</li>
<li>将指针p向后移动一个结点，再输出结点数据；</li>
<li>如此继续下去直到链表的尾结点。</li>
</ol>
<p>结点由存放数据元素的数据域和存放后继结点地址的指针域组成</p>
<ol>
<li><p>链表插入操作的实现方法：</p>
<ul>
<li>找到链表中要插入的位置</li>
<li>令待插入结点的next指针指向插入位置的当前结点</li>
<li>令插入位置之前的当前结点的next指针指向待插入结点</li>
</ul>
</li>
<li><p>链表遍历操作的实现方法：</p>
<ul>
<li>定义一个用于遍历的变量，初始指向头结点</li>
<li>输出遍历变量所在结点的值，并更新遍历变量为当前结点的下一个结点</li>
<li>重复操作2，直到遍历完所有结点</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListF</span><span class="params">(LinkList &amp;L, ElemType a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 头插法建立单链表</span></span><br><span class="line">    LinkList s;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListR</span><span class="params">(LinkList&amp; L, ElemType a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//尾插法建立单链表</span></span><br><span class="line">    LinkList s, r;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList&amp; L)</span> </span>&#123; <span class="comment">// 初始化线性表</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(LinkList&amp; L)</span> </span>&#123; <span class="comment">// 销毁链表</span></span><br><span class="line">    LinkList pre = L, p = pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pre);</span><br><span class="line">        pre = p;</span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span> </span>&#123; <span class="comment">// 判断链表是否为空表</span></span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L, s;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L, q;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList h;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单链表的基本运算如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（1）初始化单链表h\n&quot;</span>);</span><br><span class="line">    InitList(h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（2）依次采用尾插法插入a, b, c, d, e元素\n&quot;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（3）输出单链表h：&quot;</span>);</span><br><span class="line">    DispList(h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（4）单链表h长度：%d\n&quot;</span>, ListLength(h));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（5）单链表h为%s\n&quot;</span>, ListEmpty(h) ? <span class="string">&quot;空&quot;</span> : <span class="string">&quot;非空&quot;</span>);</span><br><span class="line">    GetElem(h, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（6）单链表h上的第3个元素：%c\n&quot;</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（7）元素a的位置：%d\n&quot;</span>, LocateElem(h, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（8）在第4个元素位置上插入f元素\n&quot;</span>);</span><br><span class="line">    ListInsert(h, <span class="number">4</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（9）输出单链表h：&quot;</span>);</span><br><span class="line">    DispList(h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（10）删除h的第3个元素\n&quot;</span>);</span><br><span class="line">    ListDelete(h, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（11）输出单链表h：&quot;</span>);</span><br><span class="line">    DispList(h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（12）释放单链表h\n&quot;</span>);</span><br><span class="line">    DestoryList(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4156/image-20220223223428452.png" alt="image-20220223223428452"></p>
<h1 id="3-栈"><a href="#3-栈" class="headerlink" title="3 栈"></a>3 栈</h1><h2 id="3-1-栈的定义"><a href="#3-1-栈的定义" class="headerlink" title="3.1 栈的定义"></a>3.1 栈的定义</h2><p>栈是限定仅在表位进行插入和删除操作的线性表</p>
<p>我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表，简称LFO结构。只能对栈顶元素进行操作，我们把栈的插入，删除操作改名为push，pop</p>
<p><strong>栈的插入操作，</strong> 叫做进栈，也称压栈，入栈</p>
<p><strong>栈的删除操作，</strong> 叫做出栈，也有的叫做弹栈</p>
<h2 id="3-2-栈的顺序存储结构"><a href="#3-2-栈的顺序存储结构" class="headerlink" title="3.2 栈的顺序存储结构"></a>3.2 栈的顺序存储结构</h2><p>我们定义一个top变量来指示栈顶元素在数组中的位置，且其小于栈的长度StackSize，一般采用下标为0的一端作为栈底，当栈存在一个元素时，top等于0。因此空栈的判断条件为top = -1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SElemType* base;</span><br><span class="line">    SElemType* top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    S.base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">DestoryStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base) &#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base)</span><br><span class="line">        S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack&amp; S, SElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base &gt;= S.stacksize) &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize + STACKINCREMENT) * <span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SElemType e;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序栈s的基本运算如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（1）初始化栈s\n&quot;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（2）栈为%s\n&quot;</span>, (<span class="built_in">StackEmpty</span>(S) ? <span class="string">&quot;空&quot;</span> : <span class="string">&quot;非空&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（3）依次进栈元素a, b, c, d, e\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Push</span>(S, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">Push</span>(S, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="built_in">Push</span>(S, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="built_in">Push</span>(S, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    <span class="built_in">Push</span>(S, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（4）栈为%s\n&quot;</span>, (<span class="built_in">StackEmpty</span>(S) ? <span class="string">&quot;空&quot;</span> : <span class="string">&quot;非空&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（5）出栈队列：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（6）栈为%s\n&quot;</span>, (<span class="built_in">StackEmpty</span>(S) ? <span class="string">&quot;空&quot;</span> : <span class="string">&quot;非空&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（7）释放栈\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DestoryStack</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4 队列"></a>4 队列</h1><h2 id="4-1-基本知识"><a href="#4-1-基本知识" class="headerlink" title="4.1 基本知识"></a>4.1 基本知识</h2><p>先进先出</p>
<ol>
<li><p>队列的插入操作实现方法：</p>
<ul>
<li>判断队列是否已满，实际上是由于队尾标记不断增加，需要判断队尾标记是否大于数组长度</li>
<li>更新队尾标记，将新插入元素存入队尾</li>
</ul>
</li>
<li><p>队列的遍历操作实现方法：</p>
<ul>
<li>输出队首标记所在的元素</li>
<li>队首标记后移一位</li>
<li>若队尾标记和队首标记相等，输出最后一个元素，否则返回步骤1</li>
</ul>
</li>
<li><p>队列出队操作的实现方法：</p>
<ul>
<li>比较队尾标记和队首标记的大小，当队首标记大于队尾标记则说明队列为空了，此时出队操作是非法的</li>
<li>令队首标记后移一位，队首标记后移即视作原队首出队了*</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail, length;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Queue *q, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br><span class="line">    q-&gt;length = length;</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail + <span class="number">1</span> &gt;= q-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;tail++;</span><br><span class="line">    q-&gt;data[q-&gt;tail] = element;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;head; i &lt;= q-&gt;tail; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首元素输出函数 front</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除队首元素函数 pop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    q-&gt;head++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空的函数 empty</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;head &gt; q-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    init(<span class="built_in">queue</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        push(<span class="built_in">queue</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    output(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">if</span>(!empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, front(<span class="built_in">queue</span>));</span><br><span class="line">        pop(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    output(<span class="built_in">queue</span>);</span><br><span class="line">    clear(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-循环队列"><a href="#4-2-循环队列" class="headerlink" title="4.2 循环队列"></a>4.2 循环队列</h2><p>上面的队列实现方式有一个问题：假上溢</p>
<p>循环队列，当队尾标记<code>tail</code>到达队列上限后，如果队列内的元素没有达到上限，就跳转到数组的开始位置，也就是0的位置，也就是0的位置，队首标记到达队列上限也采取同样的处理。通过这样的方法，我们就能够最大化利用内存空间，避免“假上溢”的情况出现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail, length, count;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Queue *q, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br><span class="line">    q-&gt;length = length;</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;count &gt;= q-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;tail = (q-&gt;tail + <span class="number">1</span>) % q-&gt;length;</span><br><span class="line">    q-&gt;data[q-&gt;tail] = element;</span><br><span class="line">    q-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = q-&gt;head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;data[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % q-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">while</span>(i != (q-&gt;tail + <span class="number">1</span>) % q-&gt;length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    q-&gt;head = (q-&gt;head + <span class="number">1</span>) % q-&gt;length;</span><br><span class="line">    q-&gt;count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    init(q, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        push(q, i);</span><br><span class="line">    &#125;</span><br><span class="line">    output(q);</span><br><span class="line">    <span class="keyword">if</span> (!empty(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, front(q));</span><br><span class="line">        pop(q);        </span><br><span class="line">    &#125;</span><br><span class="line">    output(q);</span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-树和二叉树"><a href="#5-树和二叉树" class="headerlink" title="5 树和二叉树"></a>5 树和二叉树</h1><h2 id="5-1-树"><a href="#5-1-树" class="headerlink" title="5.1 树"></a>5.1 树</h2><h3 id="5-1-1-概念"><a href="#5-1-1-概念" class="headerlink" title="5.1.1 概念"></a>5.1.1 概念</h3><p>树有且仅有一个上面的树根。树是由若干个有限结点组成的一个具有层次关系的集合，最上面的结点为树的根结点</p>
<p>结点拥有的子树个数我们称为结点的度</p>
<h3 id="5-1-2-性质"><a href="#5-1-2-性质" class="headerlink" title="5.1.2 性质"></a>5.1.2 性质</h3><p>每棵非空树有且仅有一个根结点</p>
<p>在树上，从一个结点出发可以访问到其余的结点，并且一个结点到另一个结点的路径有且仅有一条</p>
<p>父亲结点可以有多个孩子结点，除根结点外，其余的结点有且仅有一个父亲结点。</p>
<p>根结点没有父亲结点，叶结点没有孩子结点</p>
<h2 id="5-2-二叉树"><a href="#5-2-二叉树" class="headerlink" title="5.2 二叉树"></a>5.2 二叉树</h2><h3 id="5-2-1-概念"><a href="#5-2-1-概念" class="headerlink" title="5.2.1 概念"></a>5.2.1 概念</h3><p>二叉树的每个结点最多只有两个孩子结点。二叉树有5种基本形态：空二叉树（树为空没有结点）、只有根结点的二叉树、只有左子树的二叉树、只有右子树的二叉树、左右子树都有的二叉树</p>
<h3 id="5-2-2-性质"><a href="#5-2-2-性质" class="headerlink" title="5.2.2 性质"></a>5.2.2 性质</h3><p>二叉树的第 i 层最多有 $2^{i-1}$ 个结点。由定义可知，二叉树的每个结点最多有两个孩子结点，那么第 i 层最多的结点数等于第 i - 1 层最多结点数的2倍。而第 1 层最多只有1个结点，所以我们可以知道第 i 层最多有 $2^{i-1}$ 个结点</p>
<p>深度为 k 的二叉树最多有 $2^k$ - 1 个结点。由上一个性质，我们可以知道二叉树每层最多的结点个数，从第 1 层到第 k 层把最多结点数累加起来，我们就可以得到深度为 k 的二叉树最多有 $2^k$ - 1个结点</p>
<p>任意一棵二叉树上，其叶子结点个数 $n_0$ 比度为2的结点数 $n_2$ 多1。我们记树上结点总个数为n，度为1的结点个数为 $n_1$ ，则有 n = $n_0$ + $n_1$ + $n_2$。另外我们可以发现一棵二叉树一共有 n - 1条边，度为2的结点可以延伸出两条边，度为1的结点可以延伸出一条边，叶子结点没有边延伸出来，所以又有 n - 1 = $n_1$ + 2 $\times$ $n_2$。结合以上两个式子，我们可以得到 $n_0$ = $n_2$ + 1</p>
<h3 id="5-2-3-两个特殊的二叉树"><a href="#5-2-3-两个特殊的二叉树" class="headerlink" title="5.2.3 两个特殊的二叉树"></a>5.2.3 两个特殊的二叉树</h3><p><strong>满二叉树：</strong>如果一棵树深度为 k 而且有 $2^k$ - 1个结点，那么我们称该二叉树为满二叉树，也就是说在此深度上，不能再添加结点了</p>
<p><strong>完全二叉树：</strong>如果一棵树深度为k，从第 1 层到第 k - 1层该树是满二叉树，第 k 层的结点都集中在左边，那么我们称该二叉树为完全二叉树。完全二叉树因其结构的特殊性具有很高的效率，经常被用在算法的优化里</p>
<h3 id="5-2-4-二叉树的广义表表达形式"><a href="#5-2-4-二叉树的广义表表达形式" class="headerlink" title="5.2.4 二叉树的广义表表达形式"></a>5.2.4 二叉树的广义表表达形式</h3><p>我们可以用广义表来表示二叉树，形式为 a(b, c)，表示根结点a的左孩子结点为b，右孩子结点为c。中间用一个逗号隔开。如果左右孩子结点不为空，则用以上形式来替换；如果结点为空，则不填任何字符。以下是几种常见的格式：</p>
<ul>
<li>a：表示根结点为a，左右孩子结点均为空</li>
<li>a(b)：表示根结点为a，左孩子结点为b，右孩子结点为空</li>
<li>a(, c)：表示根结点为a，左孩子结点为空，右孩子结点为c</li>
<li>a(b, c)：表示根结点为a，左孩子结点为b，右孩子结点为c</li>
</ul>
<p>如 7(4(3, 6), 15(, 55)) 可以表示以下这棵二叉树：</p>
<p>如何将广义表创建成二叉树：</p>
<p>将广义表创建成二叉树，可以借助栈来实现，利用栈先进后出的特点，先将根结点压入栈中，如果左孩子结点不为空，则将其作为栈顶结点（即其父亲结点）的左孩子结点，并压入栈中，递归左子树，处理完之后左孩子节点出战；如果右孩子不为空，则将其作为栈顶结点（即其父亲结点）的右孩子结点，并压入栈中，递归右子树，处理完之后右孩子结点出栈</p>
<h2 id="5-3-二叉树的存储结构"><a href="#5-3-二叉树的存储结构" class="headerlink" title="5.3 二叉树的存储结构"></a>5.3 二叉树的存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现二叉树的各种基本运算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTree</span><span class="params">(BTNode*&amp; b, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    BTNode* St[MAXSIZE], * p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    ch = str[j];</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>(<span class="string">&#x27;:</span></span><br><span class="line">            top++;</span><br><span class="line">            St[top] = p;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>)<span class="string">&#x27;:</span></span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>,<span class="string">&#x27;:</span></span><br><span class="line">            k = 2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">            p-&gt;data = ch;</span><br><span class="line">            p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">                b = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span> (k) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    St[top]-&gt;lchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    St[top]-&gt;rchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        ch = str[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryBTree</span><span class="params">(BTNode*&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DestoryBTree</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">DestoryBTree</span>(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">FindNode</span><span class="params">(BTNode* b, ElemType x)</span> </span>&#123;</span><br><span class="line">    BTNode* p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="built_in">FindNode</span>(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FindNode</span>(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">LchildNode</span><span class="params">(BTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">RchildNode</span><span class="params">(BTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTHeight</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildh, rchildh;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lchildh = <span class="built_in">BTHeight</span>(b-&gt;lchild);</span><br><span class="line">        rchildh = <span class="built_in">BTHeight</span>(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (lchildh &gt; rchildh ? (lchildh + <span class="number">1</span>) : (rchildh + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispBTree</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBTree</span>(b-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBTree</span>(b-&gt;rchild);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BTNode* b, * p, * lp, * rp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树的基本运算如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（1）创建二叉树\n&quot;</span>);</span><br><span class="line">    <span class="built_in">CreateBTree</span>(b, <span class="string">&quot;A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（2）输出二叉树&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（3）H结点：&quot;</span>);</span><br><span class="line">    p = <span class="built_in">FindNode</span>(b, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lp = <span class="built_in">LchildNode</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (lp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;左孩子为%c&quot;</span>, lp-&gt;data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无左孩子&quot;</span>);</span><br><span class="line">        rp = <span class="built_in">RchildNode</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (rp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;右孩子为%c&quot;</span>, rp-&gt;data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无右孩子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（4）二叉树b的高度：%d\n&quot;</span>, <span class="built_in">BTHeight</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;（5）释放二叉树b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DestoryBTree</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-遍历二叉树"><a href="#5-4-遍历二叉树" class="headerlink" title="5.4 遍历二叉树"></a>5.4 遍历二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现二叉树各种遍历算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTree</span><span class="params">(BTNode*&amp; b, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    BTNode* St[MAXSIZE], * p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    ch = str[j];</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>(<span class="string">&#x27;:</span></span><br><span class="line">            top++;</span><br><span class="line">            St[top] = p;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>)<span class="string">&#x27;:</span></span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>,<span class="string">&#x27;:</span></span><br><span class="line">            k = 2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BTNode));</span><br><span class="line">            p-&gt;data = ch;</span><br><span class="line">            p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">                b = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span> (k) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    St[top]-&gt;lchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    St[top]-&gt;rchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        ch = str[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryBTree</span><span class="params">(BTNode*&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DestoryBTree</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">DestoryBTree</span>(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">FindNode</span><span class="params">(BTNode* b, ElemType x)</span> </span>&#123;</span><br><span class="line">    BTNode* p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="built_in">FindNode</span>(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FindNode</span>(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">LchildNode</span><span class="params">(BTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">RchildNode</span><span class="params">(BTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTHeight</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildh, rchildh;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lchildh = <span class="built_in">BTHeight</span>(b-&gt;lchild);</span><br><span class="line">        rchildh = <span class="built_in">BTHeight</span>(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (lchildh &gt; rchildh ? (lchildh + <span class="number">1</span>) : (rchildh + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispBTree</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBTree</span>(b-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBTree</span>(b-&gt;rchild);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为btree.cpp 包含二叉树的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 先序遍历递归算法</span></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);  <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;lchild);  <span class="comment">// 递归访问左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;rchild);  <span class="comment">//递归访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder1</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 先序非递归遍历算法</span></span><br><span class="line">    BTNode* St[MAXSIZE], * p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        top++;  <span class="comment">// 根结点进栈</span></span><br><span class="line">        St[top] = b;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span>) &#123;  <span class="comment">// 栈不为空时循环</span></span><br><span class="line">            p = St[top];  <span class="comment">// 退栈并访问该结点</span></span><br><span class="line">            top--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;  <span class="comment">// 有右孩子，将其进栈</span></span><br><span class="line">                top++;</span><br><span class="line">                St[top] = p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;  <span class="comment">// 有左孩子，将其进栈</span></span><br><span class="line">                top++;</span><br><span class="line">                St[top] = p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 中序遍历的递归算法</span></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;lchild);  <span class="comment">// 递归访问左子树</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);  <span class="comment">// 访问根结点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;rchild);  <span class="comment">// 递归访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder1</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 中序非递归遍历算法</span></span><br><span class="line">    BTNode* St[MAXSIZE], * p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = b;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span> || p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;  <span class="comment">// 扫描结点p的所有左下结点并进栈</span></span><br><span class="line">                top++;</span><br><span class="line">                St[top] = p;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                p = St[top];  <span class="comment">// 出栈结点p并访问</span></span><br><span class="line">                top--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 后序遍历的递归算法</span></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;lchild);  <span class="comment">// 递归访问左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;rchild);  <span class="comment">// 递归访问右子树</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);  <span class="comment">// 访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder1</span><span class="params">(BTNode* b)</span> </span>&#123;  <span class="comment">// 后序非递归遍历算法</span></span><br><span class="line">    BTNode* St[MAXSIZE];</span><br><span class="line">    BTNode* p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">// 栈指针置初值</span></span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>) &#123;  <span class="comment">// 将b结点的所有左下结点进栈</span></span><br><span class="line">                top++;</span><br><span class="line">                St[top] = b;</span><br><span class="line">                b = b-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            p = <span class="literal">NULL</span>;  <span class="comment">// p指向当前结点的前一个已访问的结点</span></span><br><span class="line">            flag = <span class="literal">true</span>;  <span class="comment">// flag为真表示正在处理栈顶结点</span></span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; flag) &#123;</span><br><span class="line">                b = St[top];  <span class="comment">// 取出当前的栈顶元素</span></span><br><span class="line">                <span class="keyword">if</span> (b-&gt;rchild == p) &#123;  <span class="comment">// 右子树不存在或已被访问</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);  <span class="comment">// 访问b结点</span></span><br><span class="line">                    top--;</span><br><span class="line">                    p = b;  <span class="comment">// p指向被访问的结点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    b = b-&gt;rchild;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (top != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TravLevel</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    BTNode* Qu[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);</span><br><span class="line">    rear++;</span><br><span class="line">    Qu[rear] = b;</span><br><span class="line">    <span class="keyword">while</span> (rear != front) &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        b = Qu[front];</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;lchild-&gt;data);</span><br><span class="line">            rear = (rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">            Qu[rear] = b-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;rchild-&gt;data);</span><br><span class="line">            rear = (rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">            Qu[rear] = b-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BTNode* b;</span><br><span class="line">    <span class="built_in">CreateBTree</span>(b, <span class="string">&quot;A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树b：&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;层次遍历序列：&quot;</span>);</span><br><span class="line">    <span class="built_in">TravLevel</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历序列：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">PreOrder</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  非递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">PreOrder1</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历序列：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">InOrder</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  非递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">InOrder1</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历序列：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">PostOrder</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  非递归算法：&quot;</span>);</span><br><span class="line">    <span class="built_in">PostOrder1</span>(b);</span><br><span class="line">    <span class="built_in">DestoryBTree</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-赫夫曼树及其应用"><a href="#5-5-赫夫曼树及其应用" class="headerlink" title="5.5 赫夫曼树及其应用"></a>5.5 赫夫曼树及其应用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50  <span class="comment">//叶子结点总数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2*N-1  <span class="comment">// 树中结点总数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">5</span>];  <span class="comment">// 结点值</span></span><br><span class="line">    <span class="keyword">int</span> weight;  <span class="comment">// 权重</span></span><br><span class="line">    <span class="keyword">int</span> parent;  <span class="comment">// 双亲结点</span></span><br><span class="line">    <span class="keyword">int</span> lchild;  <span class="comment">// 左孩子结点</span></span><br><span class="line">    <span class="keyword">int</span> rchild;  <span class="comment">// 右孩子结点</span></span><br><span class="line">&#125;HTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cd[N];  <span class="comment">// 存放哈夫曼编码</span></span><br><span class="line">    <span class="keyword">int</span> start;  <span class="comment">// ch[start.n]存放哈夫曼编码</span></span><br><span class="line">&#125;HCode;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHT</span><span class="params">(HTNode ht[], <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">// 由ht的叶子结点构造完整的哈夫曼树</span></span><br><span class="line">    <span class="keyword">int</span> i, k, lnode, rnode;</span><br><span class="line">    <span class="keyword">int</span> min1, min2;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++)  <span class="comment">// 所有结点的相关域置初值-1</span></span><br><span class="line">        ht[i].parent = ht[i].lchild = ht[i].rchild = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;  <span class="comment">// 构造哈夫曼树的分支结点</span></span><br><span class="line">        min1 = min2 = <span class="number">32767</span>;  <span class="comment">// lnode和rnode为最小权重的两个结点位置</span></span><br><span class="line">        lnode = rnode = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= i - <span class="number">1</span>; k++)  <span class="comment">// 查找最小和次小结点</span></span><br><span class="line">            <span class="keyword">if</span> (ht[k].parent == <span class="number">-1</span>) &#123;  <span class="comment">// 只在尚未构造二叉树的结点中查找</span></span><br><span class="line">                <span class="keyword">if</span> (ht[k].weight &lt; min1) &#123;</span><br><span class="line">                    min2 = min1;</span><br><span class="line">                    rnode = lnode;</span><br><span class="line">                    min1 = ht[k].weight;</span><br><span class="line">                    lnode = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ht[k].weight &lt; min2) &#123;</span><br><span class="line">                    min2 = ht[k].weight;</span><br><span class="line">                    rnode = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ht[lnode].parent = i;  <span class="comment">// 合并两个最小和次小的结点</span></span><br><span class="line">        ht[rnode].parent = i;</span><br><span class="line">        ht[i].weight = ht[lnode].weight + ht[rnode].weight;</span><br><span class="line">        ht[i].lchild = lnode;</span><br><span class="line">        ht[i].rchild = rnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHCode</span><span class="params">(HTNode ht[], HCode hcd[], <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">// 由哈夫曼树ht构造哈夫曼编码hcd</span></span><br><span class="line">    <span class="keyword">int</span> i, f, c;</span><br><span class="line">    HCode hc;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 根据哈夫曼树构造所有叶子结点的哈夫曼编码</span></span><br><span class="line">        hc.start = n;</span><br><span class="line">        c = i;</span><br><span class="line">        f = ht[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">-1</span>) &#123;  <span class="comment">// 循环直到树根结点</span></span><br><span class="line">            <span class="keyword">if</span> (ht[f].lchild == c)  <span class="comment">// 处理左孩子结点</span></span><br><span class="line">                hc.cd[hc.start--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 处理右孩子结点</span></span><br><span class="line">                hc.cd[hc.start--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            c = f;</span><br><span class="line">            f = ht[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        hc.start++;  <span class="comment">// start指向哈夫曼编码最开始字符</span></span><br><span class="line">        hcd[i] = hc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispHCode</span><span class="params">(HTNode ht[], HCode hcd[], <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">// 输出哈夫曼编码</span></span><br><span class="line">    <span class="keyword">int</span> i, k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, m = <span class="number">0</span>, j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出哈夫曼编码：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   %s\t&quot;</span>, ht[i].data);</span><br><span class="line">        <span class="keyword">for</span> (k = hcd[i].start; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, hcd[i].cd[k]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        m += ht[i].weight;</span><br><span class="line">        sum += ht[i].weight * j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n平均长度=%g\n&quot;</span>, <span class="number">1.0</span> * sum / m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">15</span>, i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str[] = &#123; <span class="string">&quot;The&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;that&quot;</span>, <span class="string">&quot;he&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;at&quot;</span>, <span class="string">&quot;on&quot;</span>, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;His&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;be&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> fnum[] = &#123; <span class="number">1192</span>, <span class="number">677</span>, <span class="number">541</span>, <span class="number">518</span>, <span class="number">462</span>, <span class="number">450</span>, <span class="number">242</span>, <span class="number">195</span>, <span class="number">190</span>, <span class="number">181</span>, <span class="number">174</span>, <span class="number">157</span>, <span class="number">138</span>, <span class="number">124</span>, <span class="number">123</span> &#125;;</span><br><span class="line">    HTNode ht[M];</span><br><span class="line">    HCode hcd[N];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(ht[i].data, str[i]);</span><br><span class="line">        ht[i].weight = fnum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateHT</span>(ht, n);  <span class="comment">// 创建哈夫曼树</span></span><br><span class="line">    <span class="built_in">CreateHCode</span>(ht, hcd, n);  <span class="comment">// 构造哈夫曼编码</span></span><br><span class="line">    <span class="built_in">DispHCode</span>(ht, hcd, n);  <span class="comment">// 输出哈夫曼编码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-图"><a href="#6-图" class="headerlink" title="6 图"></a>6 图</h1><h2 id="6-1-什么是图"><a href="#6-1-什么是图" class="headerlink" title="6.1 什么是图"></a>6.1 什么是图</h2><p>图是由一系列顶点和若干连结顶点集合内两个顶点的边组成的数据结构。通常我们用G = (V, E) 表示一个图结构，其中V表示点集，E表示边集</p>
<p>在顶点集合所包含的若干个顶点之间，可能存在这某种两两对应关系——如果某两个点之间的确存在这样的关系的话，我们就在这两个点之间连边，这样就得到了边集的一个成员，也就是一条边。对应到社交网络上，顶点就是网络中的用户，边就是用户之间的好友关系</p>
<h2 id="6-2-图的常用概念"><a href="#6-2-图的常用概念" class="headerlink" title="6.2 图的常用概念"></a>6.2 图的常用概念</h2><p>如果图中所有边都是无向边，则称为无向图，反之称为有向图</p>
<p>有很少边或弧（如 e &lt; nlogn，e指边数，n指点数）的图称为稀疏图，反之称为稠密图。顶点的<strong>度</strong>是指依附于某个顶点的边数。在有向图中，顶点的<strong>入度</strong>是指以顶点为弧头的弧的数目，也就是以该顶点为终点的弧的数目；顶点的<strong>出度</strong>是指以顶点为弧尾的弧的数目，也就是以该顶点为起点的弧的数目，在有向图里，顶点的度为入度和出度之和。在无向图里，图中的边数等于所有顶点度数和的一半</p>
<h2 id="6-3-图的存储方式"><a href="#6-3-图的存储方式" class="headerlink" title="6.3 图的存储方式"></a>6.3 图的存储方式</h2><p>两个常见的图的存储结构——<strong>邻接矩阵</strong>和<strong>邻接表</strong>。邻接矩阵就是用一维数组存储图中顶点的信息，用矩阵表示图中各顶点之间的邻接关系</p>
<p>对于有n个顶点的图 G = (V, E) 来说，我们可以用一个 n $\times$ n 的矩阵A来表示G中各顶点的相邻关系，如果$v_i$和$v_j$之间存在边（或弧），则A$[i]$$[j]$ = 1，否则A$[i]$$[j]$ = 0。下图为有向图$G_1$和无向图$G_2$对应的邻接矩阵：</p>
<p>图的邻接矩阵是唯一的，矩阵的大小只与顶点个数N有关，是一个N $\times$ N 的矩阵。在无向图里，如果顶点 $v_i$ 和 $v_j$ 之间有边，则可认为顶点 $v_i$ 到 $v_j$ 有边，顶点 $v_j$ 到 $v_i$ 也有边。对应到邻接矩阵里，则有A$[i]$ $[j]$ = A$[j]$$[i]$ = 1。无向图的邻接矩阵是一个对称矩阵</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现图的邻接矩阵和邻接表存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &lt; n;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MatGraph g;</span><br><span class="line">    AdjGraph* G;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">5</span>,INF,<span class="number">7</span>,INF,INF&#125;,&#123;INF,<span class="number">0</span>,<span class="number">4</span>,INF,INF,INF&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>,INF,<span class="number">0</span>,INF,INF,<span class="number">9</span>&#125;,&#123;INF,INF,<span class="number">5</span>,<span class="number">0</span>,INF,<span class="number">6</span>&#125;,</span><br><span class="line">        &#123;INF,INF,INF,<span class="number">5</span>,<span class="number">0</span>,INF&#125;,&#123;<span class="number">3</span>,INF,INF,INF,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateMat</span>(g, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(1)图G的邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispMat</span>(g);</span><br><span class="line">    <span class="built_in">CreateAdj</span>(G, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(2)图G的邻接表：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispAdj</span>(G);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(3)销毁图G的邻接表\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DestoryAdj</span>(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-图的遍历"><a href="#6-4-图的遍历" class="headerlink" title="6.4 图的遍历"></a>6.4 图的遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AdjGraph* G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    p = G-&gt;adjlist[v].firstarc;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(G, p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(AdjGraph* G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">int</span> St[MAXV];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, w, x, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    top++;</span><br><span class="line">    St[top] = v;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        x = St[top];</span><br><span class="line">        p = G-&gt;adjlist[x].firstarc;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            w = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (visited[w] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, w);</span><br><span class="line">                visited[w] = <span class="number">1</span>;</span><br><span class="line">                top++;</span><br><span class="line">                St[top] = w;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">            top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(AdjGraph* G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">int</span> queue[MAXV], front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> visited[MAXV];</span><br><span class="line">    <span class="keyword">int</span> w, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % MAXV;</span><br><span class="line">    queue[rear] = v;</span><br><span class="line">    <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAXV;</span><br><span class="line">        w = queue[front];</span><br><span class="line">        p = G-&gt;adjlist[w].firstarc;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % MAXV;</span><br><span class="line">                queue[rear] = p-&gt;adjvex;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AdjGraph* G;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, INF, <span class="number">7</span>, INF, INF&#125;, &#123;INF, <span class="number">0</span>, <span class="number">4</span>, INF, INF, INF&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, INF, <span class="number">0</span>, INF, INF, <span class="number">9</span>&#125;, &#123;INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF&#125;, &#123;<span class="number">3</span>, INF, INF, INF, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateAdj</span>(G, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;图G的邻接表：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispAdj</span>(G);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点0开始的DFS（递归算法）：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DFS</span>(G, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点0开始的DFS（非递归算法）：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DFS1</span>(G, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点0开始的BFS：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">BFS</span>(G, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DestoryAdj</span>(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-最小生成树"><a href="#6-5-最小生成树" class="headerlink" title="6.5 最小生成树"></a>6.5 最小生成树</h2><p>构造连通网的最小代价生成树称为最小生成树</p>
<h3 id="6-5-1-普利姆算法"><a href="#6-5-1-普利姆算法" class="headerlink" title="6.5.1 普利姆算法"></a>6.5.1 普利姆算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prim</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(MatGraph g, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowcost[MAXV], min, n = g.n;</span><br><span class="line">    <span class="keyword">int</span> closest[MAXV], i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        lowcost[i] = g.edges[v][i];</span><br><span class="line">        closest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[k][j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j]) &#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];</span><br><span class="line">                closest[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">3</span>;</span><br><span class="line">    MatGraph g;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, INF, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF, INF&#125;, &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, INF, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, INF, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;INF, INF, INF, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, INF, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateMat</span>(g, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;图G的邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispMat</span>(g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普利姆算法求解结果：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Prim</span>(g, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-2-克鲁斯卡尔算法"><a href="#6-5-2-克鲁斯卡尔算法" class="headerlink" title="6.5.2 克鲁斯卡尔算法"></a>6.5.2 克鲁斯卡尔算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Edge E[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Edge temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        temp = E[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp.w &lt; E[j].w) &#123;</span><br><span class="line">            E[j + <span class="number">1</span>] = E[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        E[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, u1, v1, sn1, sn2, k;</span><br><span class="line">    <span class="keyword">int</span> vset[MAXV];</span><br><span class="line">    Edge E[MAXSIZE];</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                E[k].u = i;</span><br><span class="line">                E[k].v = j;</span><br><span class="line">                E[k].w = g.edges[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">InsertSort</span>(E, g.e);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        vset[i] = i;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; g.n) &#123;</span><br><span class="line">        u1 = E[j].u;</span><br><span class="line">        v1 = E[j].v;</span><br><span class="line">        sn1 = vset[u1];</span><br><span class="line">        sn2 = vset[v1];</span><br><span class="line">        <span class="keyword">if</span> (sn1 != sn2) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d):%d\n&quot;</span>, u1, v1, E[j].w);</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">                <span class="keyword">if</span> (vset[i] == sn2)</span><br><span class="line">                    vset[i] = sn1;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">3</span>;</span><br><span class="line">    MatGraph g;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, INF, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF, INF&#125;, &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, INF, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, INF, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;INF, INF, INF, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, INF, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateMat</span>(g, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;图G的邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispMat</span>(g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;克鲁斯卡尔算法求解结果：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Kruskal</span>(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-6-最短路径"><a href="#6-6-最短路径" class="headerlink" title="6.6 最短路径"></a>6.6 最短路径</h2><h3 id="6-6-1-迪杰斯特拉算法"><a href="#6-6-1-迪杰斯特拉算法" class="headerlink" title="6.6.1 迪杰斯特拉算法"></a>6.6.1 迪杰斯特拉算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispath</span><span class="params">(MatGraph g, <span class="keyword">int</span> dist[], <span class="keyword">int</span> path[], <span class="keyword">int</span> S[], <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> apath[MAXV], d;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="number">1</span> &amp;&amp; i != v) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;从顶点%d到顶点%d的路径长度为：%d\t路径为：&quot;</span>, v, i, dist[i]);</span><br><span class="line">            d = <span class="number">0</span>;</span><br><span class="line">            apath[d] = i;</span><br><span class="line">            k = path[i];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无路径\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (k != v) &#123;</span><br><span class="line">                    d++;</span><br><span class="line">                    apath[d] = k;</span><br><span class="line">                    k = path[k];</span><br><span class="line">                &#125;</span><br><span class="line">                d++;</span><br><span class="line">                apath[d] = v;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, apath[d]);</span><br><span class="line">                <span class="keyword">for</span> (j = d - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;,%d&quot;</span>, apath[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(MatGraph g, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[MAXV], path[MAXV];</span><br><span class="line">    <span class="keyword">int</span> S[MAXV];</span><br><span class="line">    <span class="keyword">int</span> Mindis, i, j, u;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];</span><br><span class="line">        S[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S[v] = <span class="number">1</span>;</span><br><span class="line">    path[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Mindis = INF;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (S[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; Mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                Mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        S[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n;j++)</span><br><span class="line">            <span class="keyword">if</span>(S[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dispath</span>(g, dist, path, S, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    MatGraph g;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, INF, <span class="number">7</span>, INF, INF&#125;, &#123;INF, <span class="number">0</span>, <span class="number">4</span>, INF, INF, INF&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, INF, <span class="number">0</span>, INF, INF, <span class="number">9</span>&#125;, &#123;INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF&#125;, &#123;<span class="number">3</span>, INF, INF, INF, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateMat</span>(g, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有向图G的邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispMat</span>(g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;迪杰斯特拉算法求解结果：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Dijkstra</span>(g, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-2-弗洛伊德算法"><a href="#6-6-2-弗洛伊德算法" class="headerlink" title="6.6.2 弗洛伊德算法"></a>6.6.2 弗洛伊德算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Floyd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 100  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> InfoType;</span><br><span class="line"><span class="comment">//以下定义邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    InfoType info;  <span class="comment">// 顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;MatGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span> &#123;</span></span><br><span class="line">    InfoType info;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[MAXV];</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"><span class="comment">//邻接矩阵的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMat</span><span class="params">(MatGraph&amp; g, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    g.n = n;</span><br><span class="line">    g.e = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            g.edges[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispMat</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != INF)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, g.edges[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%4s&quot;</span>, <span class="string">&quot;∞&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的基本运算算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdj</span><span class="params">(AdjGraph*&amp; G, <span class="keyword">int</span> A[MAXV][MAXV], <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    G = (AdjGraph*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = A[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;</span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispAdj</span><span class="params">(AdjGraph* G)</span> </span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryAdj</span><span class="params">(AdjGraph*&amp; G)</span> </span>&#123;</span><br><span class="line">    ArcNode* pre, * p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispath</span><span class="params">(MatGraph g, <span class="keyword">int</span> A[][MAXV], <span class="keyword">int</span> path[][MAXV])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, s;</span><br><span class="line">    <span class="keyword">int</span> apath[MAXV], d;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != INF &amp;&amp; i != j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;从%d到%d的路径为：&quot;</span>, i, j);</span><br><span class="line">                k = path[i][j];</span><br><span class="line">                d = <span class="number">0</span>;</span><br><span class="line">                apath[d] = j;</span><br><span class="line">                <span class="keyword">while</span> (k != <span class="number">-1</span> &amp;&amp; k != i) &#123;</span><br><span class="line">                    d++;</span><br><span class="line">                    apath[d] = k;</span><br><span class="line">                    k = path[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">                apath[d] = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, apath[d]);</span><br><span class="line">                <span class="keyword">for</span> (s = d - <span class="number">1</span>; s &gt;= <span class="number">0</span>; s--)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;,%d&quot;</span>, apath[s]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t路径长度为：%d\n&quot;</span>, A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(MatGraph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV], path[MAXV][MAXV];</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++) &#123;</span><br><span class="line">            A[i][j] = g.edges[i][j];</span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; g.edges[i][j] &lt; INF)</span><br><span class="line">                path[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; g.n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] &gt; A[i][k] + A[k][j]) &#123;</span><br><span class="line">                    A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                    path[i][j] = path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dispath</span>(g, A, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MatGraph q;</span><br><span class="line">    <span class="keyword">int</span> A[MAXV][MAXV] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, INF, <span class="number">7</span>, INF, INF&#125;, &#123;INF, <span class="number">0</span>, <span class="number">4</span>, INF, INF, INF&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, INF, <span class="number">0</span>, INF, INF, <span class="number">9</span>&#125;, &#123;INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">5</span>, <span class="number">0</span>, INF&#125;, &#123;<span class="number">3</span>, INF, INF, INF, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>, e = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CreateMat</span>(g, A, n, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有向图G的邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DispMat</span>(g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弗洛伊德算法求解结果：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">Floyd</span>(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-7-拓扑排序"><a href="#6-7-拓扑排序" class="headerlink" title="6.7 拓扑排序"></a>6.7 拓扑排序</h2><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。这样的有向图为顶点表示活动的网，我们称为<strong>AOV网</strong></p>
<p>设 G = (V, E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 $v_1$ ，$v_2$，… $v_n$ , 满足若从 顶点 $v_i$ 到 $v_j$ 有一条路径， 则在顶点序列中顶点 $v_i$ 必在顶点 $v_j$ 之前。则我们称这样的顶点序列为一个拓扑序列</p>
<p>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。构造时时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环(回路)的 AOV网； 如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环(回路)，不是 AOV 网。</p>
<p>在拓扑排序算法中，涉及的结构代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span>  <span class="comment">// 边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span> <span class="comment">// 键域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span>  <span class="comment">// 顶点表结点</span></span><br><span class="line">        <span class="keyword">int</span> in;  <span class="comment">// 顶点入度</span></span><br><span class="line">        <span class="keyword">int</span> data;  <span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">        EdgeNode *firstedge;  <span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> numVertexes, numEdges;  <span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;graphAdjList, * GraphAdjList;</span><br></pre></td></tr></table></figure>

<p>具体代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> </span>&#123;</span><br><span class="line">    EdgeNode* e;</span><br><span class="line">    <span class="keyword">int</span> i, k, gettop;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;  <span class="comment">// 用于栈指针下标</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span>* stack;  <span class="comment">// 建栈存储入度为0的顶点</span></span><br><span class="line">    stack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;GL -&gt;numVertexes; i++)</span><br><span class="line">        <span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">            stack[++top] = i;  <span class="comment">// 将入度为0的顶点入栈</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">0</span>) &#123;</span><br><span class="line">        gettop = stack[top--]; <span class="comment">// 出栈</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, GL-&gt;adjList[gettop].data);  <span class="comment">// 打印此顶点</span></span><br><span class="line">        count++;  <span class="comment">// 统计输出顶点数</span></span><br><span class="line">        <span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;  <span class="comment">// 对此顶点弧表遍历</span></span><br><span class="line">            k = e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))  <span class="comment">// 将k号顶点邻接点的入度减1</span></span><br><span class="line">                stack[++top] = k;  <span class="comment">// 若为0则入栈，以便于下次循环输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; GL-&gt;numVertexes)  <span class="comment">// 如果 count 小于顶点数，说明存在环</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-8-关键路径"><a href="#6-8-关键路径" class="headerlink" title="6.8 关键路径"></a>6.8 关键路径</h2><p>拓扑排序主要是解决一个工程能否顺序进行的问题，但有时我们还需要解决工程完成需要的最短时间问题</p>
<p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 <strong>AOE 网</strong></p>
<p>路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。</p>
<h1 id="7-查找"><a href="#7-查找" class="headerlink" title="7 查找"></a>7 查找</h1><h2 id="7-1-查找概论"><a href="#7-1-查找概论" class="headerlink" title="7.1 查找概论"></a>7.1 查找概论</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合</p>
<p><strong>关键字</strong>是数据元素中某个数据项的值。若此关键字可以唯一地标识一个记录，则称此关键字为<strong>主关键字</strong>。对于那些可以识别多个数据元素(或记 )的关键字，我们称为<strong>次关键字</strong></p>
<p><strong>查找</strong>就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>查找表按照操作方式来分有两大种：静态查找表和动态查找表</p>
<p>静态查找表：只作查找操作的查找表。它的主要操作有：</p>
<ul>
<li><p>查询某个”特定的”数据元素是否在查找表中。</p>
</li>
<li><p>检索某个”特定的”数据元素和各种属性。</p>
</li>
</ul>
<p>动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：</p>
<ul>
<li><p>查找时插入数据元素。</p>
</li>
<li><p>查找时删除数据元素。</p>
</li>
</ul>
<h2 id="7-2-顺序表查找"><a href="#7-2-顺序表查找" class="headerlink" title="7.2 顺序表查找"></a>7.2 顺序表查找</h2><p>要针对这一线性表进行查找操作，因此它就是静态查找表</p>
<p><strong>顺序查找</strong>又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</p>
<h3 id="7-2-1-顺序表查找算法"><a href="#7-2-1-顺序表查找算法" class="headerlink" title="7.2.1 顺序表查找算法"></a>7.2.1 顺序表查找算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Seguential_Search</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i J == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-顺序表查找优化"><a href="#7-2-2-顺序表查找优化" class="headerlink" title="7.2.2 顺序表查找优化"></a>7.2.2 顺序表查找优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有哨兵顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    a[<span class="number">0</span>] = key;  <span class="comment">// 设置a[0]为关键字值，我们称之为&quot;哨兵&quot;</span></span><br><span class="line">    i = n;  <span class="comment">// 循环从数组尾部开始</span></span><br><span class="line">    <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// 返回0则说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-有序表查找"><a href="#7-3-有序表查找" class="headerlink" title="7.3 有序表查找"></a>7.3 有序表查找</h2><h3 id="7-3-1-折半查找"><a href="#7-3-1-折半查找" class="headerlink" title="7.3.1 折半查找"></a>7.3.1 折半查找</h3><p>折半查找技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是:在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binaxy_Search</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;  <span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">    high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 折半</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])  <span class="comment">// 若查找值比中值小</span></span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">// 最高下标调整到中位下标大一位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])  <span class="comment">// 若查找值比中值大</span></span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 最低下标调整到中位下标大一位</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-插值查找"><a href="#7-3-2-插值查找" class="headerlink" title="7.3.2 插值查找"></a>7.3.2 插值查找</h3><p>根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。</p>
<h3 id="7-3-3-斐波那契查找"><a href="#7-3-3-斐波那契查找" class="headerlink" title="7.3.3 斐波那契查找"></a>7.3.3 斐波那契查找</h3><p>利用黄金分割原理实现</p>
<h2 id="7-4-线性索引查找"><a href="#7-4-线性索引查找" class="headerlink" title="7.4 线性索引查找"></a>7.4 线性索引查找</h2><h3 id="7-4-1-稠密索引"><a href="#7-4-1-稠密索引" class="headerlink" title="7.4.1 稠密索引"></a>7.4.1 稠密索引</h3><p>稠密索引中的索引项一定是按照关键码有序的排列</p>
<h3 id="7-4-2-分块索引"><a href="#7-4-2-分块索引" class="headerlink" title="7.4.2 分块索引"></a>7.4.2 分块索引</h3><h3 id="7-4-3-倒排索引"><a href="#7-4-3-倒排索引" class="headerlink" title="7.4.3 倒排索引"></a>7.4.3 倒排索引</h3><p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。</p>
<h2 id="7-5-二叉排序树"><a href="#7-5-二叉排序树" class="headerlink" title="7.5 二叉排序树"></a>7.5 二叉排序树</h2><p>二叉排序树，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>
<li> 若它的右子树不空 ，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左右子树也分别为二叉排序树</li>
</ul>
<h2 id="7-6-平衡二叉树"><a href="#7-6-平衡二叉树" class="headerlink" title="7.6 平衡二叉树"></a>7.6 平衡二叉树</h2><h2 id="7-7-多路查找树（B树）"><a href="#7-7-多路查找树（B树）" class="headerlink" title="7.7 多路查找树（B树）"></a>7.7 多路查找树（B树）</h2><h2 id="7-8-散列表查找"><a href="#7-8-散列表查找" class="headerlink" title="7.8 散列表查找"></a>7.8 散列表查找</h2><p>hash</p>
<h1 id="8-排序"><a href="#8-排序" class="headerlink" title="8 排序"></a>8 排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求各排序算法的绝对执行时间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(KeyType&amp; x, KeyType&amp; y)</span> </span>&#123;</span><br><span class="line">    KeyType tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt; high; i++)</span><br><span class="line">        R[i] = <span class="built_in">rand</span>() % <span class="number">99</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> R1[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R1[i] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy1</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> R1[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R1[i+<span class="number">1</span>] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(KeyType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt; high - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (R[i] &gt; R[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    KeyType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (R[i] &lt; R[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; R[j] &gt; tmp);</span><br><span class="line">            R[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;直接插入排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">InsertSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinInsertSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">    KeyType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (R[i] &lt; R[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            low = <span class="number">0</span>;</span><br><span class="line">            high = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; R[mid])</span><br><span class="line">                    high = mid <span class="number">-1</span></span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">                R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">            R[high + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinInsertSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;折半插入排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">BinInsertSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, d;</span><br><span class="line">    KeyType tmp;</span><br><span class="line">    d = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d; i &lt; n; i++) &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - d;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; R[j]) &#123;</span><br><span class="line">                R[j + d] = R[j];</span><br><span class="line">                j = j - d;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        d = d / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSortTime</span><span class="params">(KeyType R[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;希尔排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">ShellSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>()-t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">bool</span> exchange;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span> (R[j] &lt; R[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(R[j], R[j - <span class="number">1</span>]);</span><br><span class="line">                exchange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!exchange)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">BubbleSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t )/ CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(KeyType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s, j = t;</span><br><span class="line">    KeyType tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; R[j] &gt;= tmp)</span><br><span class="line">                j--;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i] &lt;= tmp)</span><br><span class="line">            i++;</span><br><span class="line">        R[j] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; t)</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="built_in">partition</span>(R, s, t);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, s, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, i + <span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;快速排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">QuickSort</span>(R, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>()-t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (R[j] &lt; R[k])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">swap</span>(R[i], R[k]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;简单选择排序\t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">SelectSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(KeyType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;</span><br><span class="line">    KeyType tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; high &amp;&amp; R[j] &lt; R[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; R[j])</span><br><span class="line">        &#123;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">sift</span>(R, i, n);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">2</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(R[<span class="number">1</span>], R[i]);</span><br><span class="line">        <span class="built_in">sift</span>(R, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆排序  \t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">HeapSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">1</span>, n))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(KeyType R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KeyType* R1;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    R1 = (KeyType*)<span class="built_in">malloc</span>((high - low + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(KeyType));</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">        <span class="keyword">if</span> (R[i] &lt;= R[j])</span><br><span class="line">        &#123;</span><br><span class="line">            R1[k] = R[i];</span><br><span class="line">            i++; k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            R1[k] = R[j];</span><br><span class="line">            j++; k++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        R1[k] = R[i];</span><br><span class="line">        i++; k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        R1[k] = R[j];</span><br><span class="line">        j++; k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = low; i &lt;= high; k++, i++)</span><br><span class="line">        R[i] = R1[k];</span><br><span class="line">    <span class="built_in">free</span>(R1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(KeyType R[], <span class="keyword">int</span> length, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">2</span> * length - <span class="number">1</span> &lt; n; i = i + <span class="number">2</span> * length )</span><br><span class="line">        <span class="built_in">Merge</span>(R, i, i + length - <span class="number">1</span>, i + <span class="number">2</span> * length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i + length - <span class="number">1</span> &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">Merge</span>(R, i, i + length - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">for</span> (length = <span class="number">1</span>; length &lt; n; length = <span class="number">2</span> * length)</span><br><span class="line">        <span class="built_in">MergePass</span>(R, length, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortTime</span><span class="params">(KeyType R[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二路归并排序  \t&quot;</span>);</span><br><span class="line">    t = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">MergeSort</span>(R, n);</span><br><span class="line">    t = <span class="built_in">clock</span>() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf秒&quot;</span>, ((<span class="keyword">float</span>)t) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test</span>(R, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t错误\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KeyType R[MaxSize], R1[MaxSize];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随机产生50000个1-99的正整数，各种排序方法的比较\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">50000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序方法         用时       结果验证\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">initial</span>(R, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">InsertSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">BinInsertSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">ShellSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">BubbleSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">QuickSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">SelectSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">HeapSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">copy</span>(R, R1, n);</span><br><span class="line">    <span class="built_in">MergeSortTime</span>(R1, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4156/image-20220223221533488.png" alt="image-20220223221533488"></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：大话数据结构笔记</li>
        <li>本文作者：馨er</li>
        <li>创建时间：2021-04-19 10:38:25</li>
        <li>
            本文链接：https://sjxbbd.vercel.app/2021/04/19/5b46925b6a72/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev" rel="prev" href="/2021/04/19/e3eebe496c88/">
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">PAT乙级-1001 害死人不偿命</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next" rel="next" href="/2021/02/03/4bc3ee7faa01/">
                            <span class="title flex-center">
                                <span class="post-nav-title-item">HTML笔记</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">馨er</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io" rel="external nofollow noopener noreferrer">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep" rel="external nofollow noopener noreferrer">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%BC%95%E8%A8%80"><span class="nav-text">1 引言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.1 基本概念和术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="nav-text">1.2 数据结构的两个层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.1 逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.2 物理结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.3 抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.3.1 数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.3.2 抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%AE%97%E6%B3%95"><span class="nav-text">1.4 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">1.4.1 算法的描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">1.4.2 算法的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">1.4.3 算法设计的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-4-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95"><span class="nav-text">1.4.4 算法效率的度量方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-5-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF"><span class="nav-text">1.4.5 函数的渐近增长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-6-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.4.6 算法时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%AD%A5%E9%AA%A4"><span class="nav-text">2  推导大O阶步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%B7%E4%BD%93%E9%98%B6%E6%95%B0"><span class="nav-text">3 具体阶数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-7-%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.4.7 算法空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1 线性表的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2 线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.3 线性表的顺序存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.4 线性表的链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%A0%88"><span class="nav-text">3 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.1 栈的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 栈的顺序存储结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%98%9F%E5%88%97"><span class="nav-text">4 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-text">4.1 基本知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">4.2 循环队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%91"><span class="nav-text">5.1 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">5.1.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%80%A7%E8%B4%A8"><span class="nav-text">5.1.2 性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.2 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">5.2.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%80%A7%E8%B4%A8"><span class="nav-text">5.2.2 性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.2.3 两个特殊的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="nav-text">5.2.4 二叉树的广义表表达形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.3 二叉树的存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.4 遍历二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-text">5.5 赫夫曼树及其应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%9B%BE"><span class="nav-text">6 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"><span class="nav-text">6.1 什么是图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-text">6.2 图的常用概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">6.3 图的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">6.4 图的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">6.5 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95"><span class="nav-text">6.5.1 普利姆算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="nav-text">6.5.2 克鲁斯卡尔算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">6.6 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-text">6.6.1 迪杰斯特拉算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="nav-text">6.6.2 弗洛伊德算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">6.7 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">6.8 关键路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%9F%A5%E6%89%BE"><span class="nav-text">7 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%9F%A5%E6%89%BE%E6%A6%82%E8%AE%BA"><span class="nav-text">7.1 查找概论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2 顺序表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-text">7.2.1 顺序表查找算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E4%BC%98%E5%8C%96"><span class="nav-text">7.2.2 顺序表查找优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3 有序表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3.1 折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3.2 插值查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3.3 斐波那契查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="nav-text">7.4 线性索引查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95"><span class="nav-text">7.4.1 稠密索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95"><span class="nav-text">7.4.2 分块索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-text">7.4.3 倒排索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-text">7.5 二叉排序树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">7.6 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88B%E6%A0%91%EF%BC%89"><span class="nav-text">7.7 多路查找树（B树）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="nav-text">7.8 散列表查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E6%8E%92%E5%BA%8F"><span class="nav-text">8 排序</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src>
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
